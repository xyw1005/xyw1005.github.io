<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>归并排序</title>
      <link href="/2019/07/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><pre><code>public class MergeSort {    public static void main(String[] args) {        int[] arr=new int[] {1,3,5,7,2,4,6,8,9};        System.err.println(Arrays.toString(arr));        //merge(arr, 0, 4, 8);         mergeSort(arr, 0, 8);        System.err.println(Arrays.toString(arr));    }    //归并排序    public static void mergeSort(int[] arr,int low,int high) {        //递归结束条件        if(low&lt;high) {            int mid=(high+low)/2;            mergeSort(arr, low, mid);            mergeSort(arr, mid+1, high);            merge(arr, low, mid, high);        }    }    //一轮归并    public static  void merge(int[]arr,int low,int mid,int high) {        int temp[]=new int[high-low+1];        int index=0;        int i=low;        int j=mid+1;        //循环条件是 左边索引小于mid ;右边索引小于high        while(i&lt;=mid&amp;&amp;j&lt;=high) {            if(arr[i]&lt;=arr[j]) {                temp[index]=arr[i];                i++;            }else {                temp[index]=arr[j];                j++;            }            index++;        }        //如果 左边剩余        1 3 5    2 4         while(i&lt;=mid) {            temp[index]=arr[i];            i++;            index++;        }        //如果 右边剩余        1 3 5    2 4 6 8        while(j&lt;=high) {            temp[index]=arr[j];            j++;            index++;        }        for(int m=0;m&lt;temp.length;m++) {            arr[m+low]=temp[m];        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2019/07/16/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/16/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>最简单的排序之一<br>核心思想：每次找出最小的数,执行n-1轮</p><img src="/2019/07/16/选择排序/select-sort-code.png"><pre><code>public class SelectSort {    public static void main(String[] args) {        int[] arr=new int[] {4,7,2,9,1,6,5,56,76,44,22,55};        selectSort(arr);        System.err.println(Arrays.toString(arr));    }    public static void selectSort(int[] arr) {        for(int i=0;i&lt;arr.length-1;i++) {            //最小的数的索引            int minIndex=i;            for(int j=i+1;j&lt;arr.length;j++) {                if(arr[minIndex]&gt;arr[j]) {                    minIndex=j;                }            }            //第i个不是最小的,则替换            if(minIndex!=i) {                int temp=arr[i];                arr[i]=arr[minIndex];                arr[minIndex]=temp;            }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2019/07/16/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/16/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我叫MT</title>
      <link href="/2019/07/16/%E6%88%91%E5%8F%ABMT/"/>
      <url>/2019/07/16/%E6%88%91%E5%8F%ABMT/</url>
      
        <content type="html"><![CDATA[<h3 id="我叫MT"><a href="#我叫MT" class="headerlink" title="我叫MT"></a>我叫MT</h3><h4 id="我叫MT-1"><a href="#我叫MT-1" class="headerlink" title="我叫MT"></a>我叫MT</h4><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5242335&auto=0&height=66"></iframe><h4 id="地狱咆哮的挽歌"><a href="#地狱咆哮的挽歌" class="headerlink" title="地狱咆哮的挽歌"></a>地狱咆哮的挽歌</h4><p>让我想起了开封府,一哥们骑着摩托车,头带半盔,脸蒙魔术头巾,车后座位放着一个正方形箱子,箱子大约到那人腋窝,箱子两边延伸到后轱辘轴承,箱子上边插着国旗,高约一米,面向我的一边写着一个大大的 <strong>死</strong>,其他小字没看清<br>,音响里放着国际歌,特有范</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5242338&auto=0&height=66"></iframe><h4 id="泰兰德的回忆"><a href="#泰兰德的回忆" class="headerlink" title="泰兰德的回忆"></a>泰兰德的回忆</h4><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5242343&auto=0&height=66"></iframe><iframe height="600" width="700" src="//player.bilibili.com/player.html?aid=12258800&cid=20200550&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我叫MT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2019/07/12/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/12/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序插图：</p><img src="/2019/07/12/插入排序/insert-sort.png"><p>代码截图</p><img src="/2019/07/12/插入排序/insert-sort-code.png"><pre><code>public class InsertSort {    public static void main(String[] args) {        int[] arr=new int[] {6,7,4,2,5};        insertSort(arr);        System.err.println(Arrays.toString(arr));    }    public static void insertSort(int[] arr) {        //第一张不用排,所以是n-1轮        for(int i=1;i&lt;arr.length;i++) {            if(arr[i]&lt;arr[i-1]) {                //记下刚刚抓的牌                int temp=arr[i];                int j;                for(j=i-1;j&gt;=0&amp;&amp;temp&lt;arr[j];j--) {                    //大的往后挪                    arr[j+1]=arr[j];                }                //本次抓的牌的位置                arr[j+1]=temp;            }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2019/07/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>松懈了,仅有的一个周日打了一下午游戏…</p><p>上图,大致描述递归实现快速排序思路</p><img src="/2019/07/08/快速排序/quick-sort.png"><p>代码截图</p><img src="/2019/07/08/快速排序/quick-sort-code.png"><pre><code>public class QuickSort {    public static void main(String[] args) {        int[] arr=new int[] {4,6,8,1,3,2,4,7,9,3};        quickSort(arr, 0, arr.length-1);        System.err.println(Arrays.toString(arr));    }    public static void quickSort(int[] arr,int start,int end) {        //起始位要小于终止位,也就是说最少两个数才能一轮进行比较        if(start&lt;end) {            //记录基准数(每轮数据的第一个数)            int mark=arr[start];            //最低位            int low=start;            //最高位            int high=end;            while(low&lt;high) {                //高位的值大于基准数时,高位减一,否则高位的值赋给低位                while(low&lt;high&amp;&amp;mark&lt;=arr[high]) {                    high--;                }                arr[low]=arr[high];                //低位的值小于基准数时,低位加一,否则低位的值赋给高位                while(low&lt;high&amp;&amp;mark&gt;=arr[low]) {                    low++;                }                arr[high]=arr[low];            }            //一轮比较完成后,把基准数赋给高位、低位重合的位置            arr[low]=mark;            //继续比较start到低位low            quickSort(arr, start, low);            //继续比较low+1到高位            quickSort(arr, low+1, end);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2019/07/05/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/05/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>困的真不开眼,闲话少说,直接上代码</p><img src="/2019/07/05/冒泡排序/buttle-sort.png"><pre><code>public class BubbleSort {    public static void main(String[] args) {        int[] arr= new int[] {4,9,7,5,1,3,7,8};        buttleSort(arr);        System.err.println(Arrays.toString(arr));    }    public static void buttleSort(int[] arr) {        //共计需要比较多少轮        for(int i=0;i&lt;arr.length-1;i++) {            //每轮比较多少次            for(int j=0;j&lt;arr.length-1-i;j++) {                if(arr[j]&gt;arr[j+1]) {                    int temp=arr[j];                    arr[j]=arr[j+1];                    arr[j+1]=temp;                }            }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汉诺塔问题</title>
      <link href="/2019/07/04/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/04/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><p><strong>百科故事：</strong></p><p>题外话之<strong>印度教</strong>：印度教是随着印度封建社会形成,种姓制度发生新变化而出现的.<br>印度教不是某位教主创立的思想体系,而是在长期社会发展过程中形成的,它是广泛吸收婆罗门教、佛教和耆那教教义<br>以及民间信仰、风俗习惯、哲学思想等的综合产物.也代指印度文化圈内所产生的宗教,是世界主要宗教之一,是印度的国教.</p><p>题外话之<strong>大梵天</strong>：梵天,是指印度教的创造之神.梵天亦称造书天,婆罗贺摩天,净天,华人地区俗称四面佛.<br>与毗湿奴,湿婆并称三主神.坐骑孔雀(或天鹅).</p><p>汉诺塔问题源于一个印度传说:大梵天创造世界的时候做了三根金刚石柱子,在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘.<br>大梵天命令婆罗门把罗盘从下面开始按照大小顺序重新摆放在另一根柱子上.<br>并规定,在小圆盘上不能放大圆盘,在三根柱子之间一次只能移动一个圆盘.</p><h3 id="递归解决汉诺塔问题"><a href="#递归解决汉诺塔问题" class="headerlink" title="递归解决汉诺塔问题"></a>递归解决汉诺塔问题</h3><p>大梵天和它的信徒说,你们把64片黄金圆盘都移过去有惊喜.</p><img src="/2019/07/04/汉诺塔问题/zan.jpg"><p>我想说这是个狠人…</p><p>f(n)=2^n-1,n=64时<br>假如每秒钟一次，共需多长时间呢？一个平年365天有31536000 秒，闰年366天有31622400秒，平均每年31556952秒，计算一下：<br>18446744073709551615秒<br>这表明移完这些金片需要5845.54亿年以上，而地球存在至今不过45亿年，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年…sruprise</p><p>这和向国王要米粒的家伙一样机智…</p><img src="/2019/07/04/汉诺塔问题/jizhi.jpg"><img src="/2019/07/04/汉诺塔问题/hanoi.png"><pre><code>public class Hanoi {    public static void main(String[] args) {        int n=6;        hanoi(n, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;);    }    /**     * 无论几个黄金圆盘，都看作是上边的和最后一个     * @param n 个数黄金圆盘     * @param from 源金刚石柱     * @param mid 中间金刚石柱     * @param target 目标金刚石柱     */    public static void hanoi(int n ,char from ,char mid,char target) {        if(n==1) {            //System.err.println(&quot;第一个黄金圆盘从&quot;+from+&quot;移到&quot;+target);        }else {            //把上边的从源 移到 中间            hanoi(n-1, from, target, mid);            //System.err.println(&quot;把第&quot;+n+&quot;个黄金圆盘从&quot;+from+&quot;移到&quot;+target);            //把上边的从中间 移到 目标            hanoi(n-1, mid, from, target);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 汉诺塔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契数列-递归</title>
      <link href="/2019/07/03/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E9%80%92%E5%BD%92/"/>
      <url>/2019/07/03/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>斐波那契数列(Fibonacci sequence),又称为<strong>黄金分割</strong>数列,因数学家 <strong>列昂纳多.斐波那契</strong>以兔子繁殖为例子而引入,又称为”兔子数列”.</p><p>指的是这样一个数列:1、1、2、3、5、8、13、21、34……在现代物理、化学等领域都有直接的应用.</p><p>生活中的斐波那契数列:观察延龄草、野玫瑰、南美血根草、大波斯菊、金凤花、耧斗菜、百合花、蝴蝶花的花瓣，可以发现它们花瓣数目具有斐波那契数：3、5、8、13、21、</p><h3 id="用递归实现斐波那契数列"><a href="#用递归实现斐波那契数列" class="headerlink" title="用递归实现斐波那契数列"></a>用递归实现斐波那契数列</h3><img src="/2019/07/03/斐波那契数列-递归/code.png"><pre><code>public class FibonacciTest {    public static void main(String[] arg){        //1 1 2 3 5        int i=fibonacci(5);        System.out.println(i);    }    public static int  fibonacci(int i){        if(i==1||i==2){            return 1;        }else{            return fibonacci(i-2)+fibonacci(i-1);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 斐波那契数列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三傻大闹宝莱坞</title>
      <link href="/2019/06/30/%E4%B8%89%E5%82%BB%E5%A4%A7%E9%97%B9%E5%AE%9D%E8%8E%B1%E5%9D%9E/"/>
      <url>/2019/06/30/%E4%B8%89%E5%82%BB%E5%A4%A7%E9%97%B9%E5%AE%9D%E8%8E%B1%E5%9D%9E/</url>
      
        <content type="html"><![CDATA[<h3 id="三傻大闹宝莱坞"><a href="#三傻大闹宝莱坞" class="headerlink" title="三傻大闹宝莱坞"></a>三傻大闹宝莱坞</h3><img src="/2019/06/30/三傻大闹宝莱坞/ruxue.jpg"><p>2019年6月30日,又在头条刷到了这部片子的片段:<br>  晚上,暴雨,兰彻偷试卷被抓遭到驱逐,碰到校长女儿分娩,兰彻和同学顺利助产,所有人喜极而泣.<br>兰彻功成身退被校长截住,赠送信仰之物-太空笔.</p><p>  校长送完太空笔那一刻,一缕阳光打到了二人身上…</p><p>  上大学时看过这部片子,我的第一部印度电影,印象深刻,对音乐、对内容.印象最深的一句话是兰彻的”追求卓越,成功自会找上你”</p><p>  Behti Hawa Sa Tha Woh</p>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5110132&auto=0&height=66"></iframe><p>  Give me some sunshine</p>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5110133&auto=0&height=66"></iframe>  <img src="/2019/06/30/三傻大闹宝莱坞/taikongbi.png">]]></content>
      
      
      <categories>
          
          <category> music </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>办护照那些事</title>
      <link href="/2019/06/25/%E5%8A%9E%E6%8A%A4%E7%85%A7%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2019/06/25/%E5%8A%9E%E6%8A%A4%E7%85%A7%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="办护照那些事"><a href="#办护照那些事" class="headerlink" title="办护照那些事"></a>办护照那些事</h3><p>前后十天,说说步骤<br>1.下载移民局App,上边有各个可办理护照的办事机构的地址和电话,可提前预约,填写邮寄地址(免费)<br>2.走起,早点去,个别的办事处周末人特别多,我在朝阳办的,周六,人山人海<img src="/2019/06/25/办护照那些事/kuxiaobude.jpg"><br>3.注意,注意,注意,穿个深色衣服,如果是女的,别画的花里胡哨的.<br>4.到地之后第一步是领取牌号照相,免费的,我10:00到,领了一个400多号的牌子….前面还有100多人<br>5.都是套路啊,办事处旁边有民间授权的照相馆,去那里70元照了一张回执单<br>6.领取表格<br>7.上交回执单,又是领取号码(B00339,前边有95人…),还好,这项业务是多线程,比较快<br>8.听号到指定窗口,基本就是核对信息,也就5分钟<br>9.ok,办妥,拿着步骤8发给你的单子去缴费160元,走人<br>10.我是第十天收到护照</p><p>没办之前以为很麻烦,没想到很简单</p><img src="/2019/06/25/办护照那些事/huzhao.jpg">]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 护照 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网分层那些事</title>
      <link href="/2019/06/24/%E4%BA%92%E8%81%94%E7%BD%91%E5%88%86%E5%B1%82%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2019/06/24/%E4%BA%92%E8%81%94%E7%BD%91%E5%88%86%E5%B1%82%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="互联网分层那些事"><a href="#互联网分层那些事" class="headerlink" title="互联网分层那些事"></a>互联网分层那些事</h2><p>对于互联网分层,偶尔也能说出其中的几层的名称,但是从来没有完整的了解过。7层？5层？4层？头都大了…<br>更加甭谈每层的作用了.</p><p>从何学起呢,怎么才能最快切入,理解呢?<br>博客,我想这是最快的方式了吧,站在别人的肩膀上,借鉴大牛的视野.</p><p>找到了<strong><em>阮一峰</em></strong>的博客,有两篇文章讲分层,通俗易懂,嗯,从这里开始吧.<br>附上文章原文链接：<br>       1.<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">互联网协议入门一</a><br>       2.<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">互联网协议入门二</a></p><hr><p>先看图：</p><img src="/2019/06/24/互联网分层那些事/5ceng.png"><img src="/2019/06/24/互联网分层那些事/7-5ceng.jpg"><p>就层数来讲,你说它分为7层也好,5层也好,或者4层也好,都可以,只不过是从宏观上进行归类的不同,归根结底具体的东西还是那些,该有的也没少.<br>接下来就5层来说说每层的作用.</p><h3 id="一-实体层"><a href="#一-实体层" class="headerlink" title="一.实体层"></a>一.实体层</h3><p>描述：把电脑连接起来的物理手段.可以是光缆、电缆、双绞线、无线电波…<br>作用：负责传送0和1的电信号(利用传输介质为数据链路层提供物理连接,实现比特流的传输)</p><h3 id="二-数据链路层"><a href="#二-数据链路层" class="headerlink" title="二.数据链路层"></a>二.数据链路层</h3><p>描述：建立和管理物理节点间的链路,规定电信号的解读方式</p><p>作用：单纯的0和1是没有意义的,必有规定解读方式,数据链路层就是通过各种控制协议把物理信道变为无差错的、能可靠传输数据帧的数据链路.</p><h4 id="2-1以太网协议"><a href="#2-1以太网协议" class="headerlink" title="2.1以太网协议"></a>2.1以太网协议</h4><p>最开始的时候,电信号的分组方式是一家一个样,分久必合,统一才是大势所趋,”以太网”(Ethernet)协议逐渐占据主导地位.</p><p>以太网规定,一组电信号构成一个数据包,叫做”帧”(Frame)。每一帧分为两个部分：标头(Head)和数据(Data).</p><img src="/2019/06/24/互联网分层那些事/ethernet-frame.png"><p>&lt;标头&gt;包含数据包的一些说明信息,比如发送者、接收者、数据类型等;&lt;标头&gt;长度是18个字节.<br>&lt;数据&gt;包含数据包的具体内容;&lt;数据&gt;长度,最短46字节,最长1500字节.<br>因此整个数据包(帧)的长度为64~1518字节.如果数据过长,就必须分割成多个帧发送.</p><h4 id="2-2MAC地址"><a href="#2-2MAC地址" class="headerlink" title="2.2MAC地址"></a>2.2MAC地址</h4><p>  以太网的”标头”包含了发送者和接收者的信息,发送者和接收者如何标识呢？</p><p>  以太网规定,连入网络的所有设备,都必须具有”网卡”接口. 数据包必须是从一块网卡,传送到另一块网卡.<br>网卡的地址就是数据包的发送地址和接收地址,称作MAC地址.</p><p>  网卡图片<br>  <img src="/2019/06/24/互联网分层那些事/wangka.jpg"></p><p>  每块网卡出厂的时候电气电子工程师协会(IEEE)负责为网卡分配 一个全世界独一无二的MAC地址,长度是48位二进制,通常用12个十六进制数表示.</p>  <img src="/2019/06/24/互联网分层那些事/macaddress.png"><p>  前6个十六进制数是厂商编号,后6个是该厂商的网卡流水号.有了MAC地址,就可以定位网卡和数据库的路径了.</p><h4 id="2-3广播"><a href="#2-3广播" class="headerlink" title="2.3广播"></a>2.3广播</h4><p>  定义地址是第一步.<br>  那么一块网卡怎么会知道另一块网卡的MAC地址呢?<br>  方法是<strong><em>ARP协议</em></strong>.  ARP(Address Resolution Protocol)即地址解析协议,是根据IP地址获取物理地址的一个TCP/IP协议.<br>  有了MAC地址之后,系统怎么才能把数据包准确送到接收方呢?</p><p>  方法很原始,它不是把数据包准确送到接收方,而是向本网络内所有计算机发送,要不要由每台计算机自己判断.<br>  <img src="/2019/06/24/互联网分层那些事/broadcast.png"><br>  上图中,1号计算机向2号计算机发送一个数据包,同一个子网络的3号、4号、5号计算机都会受到这个数据包。它们读取数据包的&lt;标头&gt;,找到目标计算机的MAC地址,然后和自身的MAC地址比较,如果两者相同,就接收这个数据包,作进一步处理,否则就丢弃这个数据包.这种发送方式叫做”广播” braodcasting</p><h3 id="三-网络层"><a href="#三-网络层" class="headerlink" title="三.网络层"></a>三.网络层</h3><h4 id="3-1网络层的由来"><a href="#3-1网络层的由来" class="headerlink" title="3.1网络层的由来"></a>3.1网络层的由来</h4><p>  以太网协议,依靠MAC地址发送数据,理论上,单单依靠MAC地址,上海的网卡就可以找到洛杉矶的网卡了,技术上是可以实现的.</p><p>  但是,这样做有一个重大的缺点.以太网采用广播方式发送数据包,所有成员人手一个数据包,不仅效率低,而且局限在发送者所在的子网络.也就是说,如果两台计算机不在同一个子网络,广播是穿不过去的.这种设计是合理的,否则互联网上每台计算机都会收到所有包,那会引起灾难.</p><p>  互联网是无数子网络共同组成的一个矩形网络,很难想象上海和洛杉矶的电脑会在同一个子网络,这几乎是不可能的.</p>  <img src="/2019/06/24/互联网分层那些事/ziwangluo.png"><p>因此,必须找到一种方法,能够区分哪些MAC地址属于同一个子网络,哪些不是.如果是同一个子网络就采用广播方式发送,否则就采用”路由”(如何向不同的子网络分发数据包)方式发送,MAC地址本身无法做到这一点.</p><p><strong><em>这就导致了”网络层”的诞生.它的作用是引进一套新的地址,使得我们能够区分不同的计算机是否属于同一个子网络.这套地址就叫做”网络地址”,简称”网址”.</em></strong></p><p>“网络层”出现以后,每台计算机有了两种地址,一种是MAC地址,另一种是网络地址.两种地址之间没有任何联系,MAC地址是绑定在网卡上的,网络地址则是管理员分配的,他们只是随机组合在一起.</p><p>网络地址帮助我们确定计算机所在的子网络,MAC地址则将数据包宋傲该子网络中的目标网卡.<br>因此,从逻辑上可以推断,必定是先处理网络地址,再处理MAC地址。</p><h4 id="3-2IP协议"><a href="#3-2IP协议" class="headerlink" title="3.2IP协议"></a>3.2IP协议</h4><p>  根据<strong><em>IP</em></strong>协议发送的数据,就叫做IP数据包。<br>  前面说过,以太网数据包只包含MAC地址,并没有IP地址的栏位.那么是否修改数据定义,在添加一个栏位呢?</p><p>  不 需 要,我们可以把<strong><em>IP</em></strong>数据包直接放进以太网数据包的”数据”部分,因此完全不用修改以太网的规格.这也是互联网分层结构的好处:上层的变动完全不涉及下层的结构.<br>具体来说,IP数据包也分为”标头”和”数据”两个部分.</p>  <img src="/2019/06/24/互联网分层那些事/ip-frame.png"><p>“标头”部分主要包括版本、长度、IP地址等信息,”数据”部分则是IP数据包的具体内容.它放进以太网数据包后,以太网数据包就变成了下面这样.</p>  <img src="/2019/06/24/互联网分层那些事/ethernet-ip.png"><p>IP数据包的”标头”部分的长度为20到60字节,整个数据包的总长度最大为65535字节.因此,理论上,一个IP数据包的”数据”部分,最长为65515字节.前面说过,以太网数据包的”数据”部分,最长只有1500字节.因此,如果IP数据包超过了1500字节,他就需要分割成几个以太网数据包,分开发送了. </p><h4 id="3-3ARP协议"><a href="#3-3ARP协议" class="headerlink" title="3.3ARP协议"></a>3.3ARP协议</h4><p>关于网络层,还有最后一点需要说明.<br>因为IP数据包是放在以太网数据包里发送的,所以我们必须同时知道两个地址,一个是对方的MAC地址,另一个是对方的IP地址.通常情况下,对方的IP地址是已知的,但是我们不知道它的MAC地址。<br>所以,我们需要一种机制,能够根据IP地址得到MAC地址。这里又分为两种情况.</p><p>  第一种情况,若果两台主机不在同一个子网络,那么事实上没有办法得到对方的MAC地址,只能把数据包床送到两个子网络连接处的”网关”(gateway),让网关去处理.</p><p>  第二种情况,如果两台主机在同一个子网络,那么我们可以使用ARP协议,得到对方的MAC地址.ARP协议也是发出一个数据包(包含在以太网数据报中),其中包含它所要查询主机的IP地址,在对方的MAC地址这一栏,填的是FF:FF:FF:FF:FF:FF,表示这是一个广播地址.它所在子网络的每一台主机,都会收到这个数据包,从中取出IP地址,与自身IP地址比较,如果相同,做出回复,向对方报告自己的MAC地址,否则就丢弃这个包.</p><p>  总之,有了ARP协议之后,我们就可以得到同一个子网络内的主机MAC地址.可以把数据包发送到任意一台主机上了.</p><h3 id="四-传输层"><a href="#四-传输层" class="headerlink" title="四.传输层"></a>四.传输层</h3><h4 id="4-1传输层的由来"><a href="#4-1传输层的由来" class="headerlink" title="4.1传输层的由来"></a>4.1传输层的由来</h4><p>有了MAC地址和IP地址,我们已经可以在互联网上任意两台主机上建立通信.</p><p>  接下来的问题是,同一台主机上有很多程序都需要用到网络,比如,一边上网一边聊天,当一个数据包从互联网上发来的时候,你怎么知道它是表示网页的内容,还是聊天的内容？</p><p>也就是说,我们还需要一个参数,表示这个数据包到底哪个程序(进程)使用.这个参数就叫”端口”Port,它其实是每一个使用网卡的程序的编号,每个数据包都发送的主机特定的端口,所以不通的程序就能取到自己所需要的数据.</p><p>“端口”是0到65535之间的一个整数,正好是16个二进制数,0到1023端口被系统占用,用户只能选用大于1023的端口.不管是浏览网页还是聊天,应用程序会随机选中一个端口,然后与服务器的相应㐰联系.</p><p><strong>*”传输层”的功能,就是建立 “端口到端口”的通信.相比之下,网络层的功能是建立”主机到主机”的通信.只要确定主机和端口,我们就能实现程序之间的交流.因此,Unix系统就把主机+端口,叫做”套接字”(socket).有了它,就可以进行网络应用程序开发了.*</strong></p><h4 id="4-2UDP协议"><a href="#4-2UDP协议" class="headerlink" title="4.2UDP协议"></a>4.2UDP协议</h4><p>现在,我们必须在数据包中加入端口信息,这就需要新的协议.最简单的实现叫做UDP协议,它的格式几乎就是在数据面前,加上端口号.</p><p>UDP数据包,也是有”标头”和”数据”两部分组成.</p>  <img src="/2019/06/24/互联网分层那些事/udp.png"><p>“标头”部分主要定义了发出端口和接收端口,”数据”部分就是具体内容.然后把整个UDP数据包放入IP数据包的数据部分,前面说过,IP数据包又是放在以太网数据包之中的,所以整个以太网数据包现在变成了下面这样:</p>  <img src="/2019/06/24/互联网分层那些事/ethernet-udp.png"><p>UDP数据包非常简单,”标头”部分一共8个字节,总长度不超过65535,正好放进一个IP数据包.</p><h4 id="4-3TCP协议"><a href="#4-3TCP协议" class="headerlink" title="4.3TCP协议"></a>4.3TCP协议</h4><p>UDP协议的有点事比较简单,容易实现,但是缺点是可靠性较差,一旦数据包发出,无法知道对方是否收到.</p><p>为了解决这个问题,提高网络可靠性,TCP协议就诞生了.这个协议非常复杂,但可以近似认为,它就是有确认机制的UDP协议,每发出一个数据包都要求确认.如果有一个数据包遗失,就说不到确认,发出方就知道有必要重发这个数据包了.</p><p>因此,TCP协议能够确保数据不会遗失,它的缺点就是过程复杂、实现困难、消耗较多的资源.</p><p>TCP数据包和UDP数据包一样,都是内嵌在IP数据包的”数据”部分,TCP数据包没有长度限制,理论上可以无限长,但是为了保障网络的效率,通常TCP数据包的长度部分超过IP数据包的长度,以确保单个TCP数据包不必在分割.</p><h3 id="五-应用层"><a href="#五-应用层" class="headerlink" title="五.应用层"></a>五.应用层</h3><p>应用程序收到”传输层”的数据,接下来就要进行解读,由于互联网是开发架构,数据来源五花八门,必须事先规定好格式,否则根本无法解读.</p><p><strong>*”应用层”的作用,就是规定应用程序的数据格式.*</strong></p><p>举例来说,TCP协议可以玩为各种各样的程序传递数据.比如Email、WWW、FTP等等.那么,必须有不同协议规定电子邮件、网页、FTP数据的格式,这些应用程序协议就构成了”应用层”.</p><p>这是最高的一层,直接面对用户.它的数据就放在TCP数据包的”数据”部分.因此,现在的以太网的数据包就变成下面这样.</p>  <img src="/2019/06/24/互联网分层那些事/ethernet-final.png"><hr>  <img src="/2019/06/24/互联网分层那些事/OSI7.png">]]></content>
      
      
      <categories>
          
          <category> 基础概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/23/hello-world/"/>
      <url>/2019/06/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>友谊之光</title>
      <link href="/2019/06/22/%E5%8F%8B%E8%B0%8A%E4%B9%8B%E5%85%89/"/>
      <url>/2019/06/22/%E5%8F%8B%E8%B0%8A%E4%B9%8B%E5%85%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Music"><a href="#Music" class="headerlink" title="Music"></a>Music</h2><p><strong><em>经常会遇到这种事,碰到一首特别符合你的心境的歌.吸引你的或是旋律,或是歌词,让你循环循环再循环,直到你的心境出现变化,把它打入你的曲库.</em></strong></p><p>　　　　　　　　　　　　　　　　　　　  说有万里山 阻隔两地遥<br>        　　　　　　　　　　　　　　　　　　　　 不需见面 心中也知晓<br>        　　　　　　　　　　　　　　　　　　　　　　　友谊改不了　</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=277766&auto=0&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> music </category>
          
      </categories>
      
      
        <tags>
            
            <tag> music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ceshi</title>
      <link href="/2019/06/16/ceshi/"/>
      <url>/2019/06/16/ceshi/</url>
      
        <content type="html"><![CDATA[<p>gitalk test</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019613001</title>
      <link href="/2019/06/13/2019613001/"/>
      <url>/2019/06/13/2019613001/</url>
      
        <content type="html"><![CDATA[<p>图片测试</p><img src="/2019/06/13/2019613001/001.jpg"><p>测试2</p><img src="/2019/06/13/2019613001/001.jpg"><p>markdown引用<br><img src="/2019613001/001.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 分类测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo上传github测试</title>
      <link href="/2019/06/11/hexo%E4%B8%8A%E4%BC%A0github%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/06/11/hexo%E4%B8%8A%E4%BC%A0github%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>this is a Test !</p>]]></content>
      
      
      <categories>
          
          <category> hexo测试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><p>博主： <img src="https://raw.githubusercontent.com/xyw1005/xyw1005.github.io/master/about/index/hongqi.png" alt>  90年 wiaoong<br>@wiaoong 当初计划要做这些</p><p>做啥呢，嗯，基本概念、数据结构、算法、音乐、摄影、杂谈，嗯够了，这些吧</p><p>每天下班有150分钟个人时间，干点啥呢，写博客吧，无论写啥都比刷头条有意义。<br>嗯，对，就是这样。<br>能坚持多久呢:<img src="https://raw.githubusercontent.com/xyw1005/xyw1005.github.io/master/about/index/think.jpg" alt> 不知道，动起来，挑战一下也是好的</p><h5 id="关于基本概念"><a href="#关于基本概念" class="headerlink" title="关于基本概念"></a>关于基本概念</h5><p>啥是HTTP,啥是HTTPS,ASCII和Utf-8啥区别，类似种种，各种概念型基础知识</p><h5 id="关于算法"><a href="#关于算法" class="headerlink" title="关于算法"></a>关于算法</h5><p>嗯，以刷题为主吧，leetcode之类的题库</p><h5 id="关于数据结构"><a href="#关于数据结构" class="headerlink" title="关于数据结构"></a>关于数据结构</h5><p>感觉这块和算法是最先坚持不住的，拭目以待吧</p><h5 id="关于音乐"><a href="#关于音乐" class="headerlink" title="关于音乐"></a>关于音乐</h5><p>有那么一瞬间，听到了一首特符合你的心境的一首歌，循环循环再循环，值得保留</p><h5 id="关于摄影："><a href="#关于摄影：" class="headerlink" title="关于摄影："></a>关于摄影：</h5><p>买了单反5年，没咋用过，浪费了，学学吧</p><h5 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h5><p>这个分类真他妈大啊，啥都能说，旅行、无意间想到的idea、牢骚…,嗯旅行可以写写，有些走过的地方都快忘了:<img src="https://raw.githubusercontent.com/xyw1005/xyw1005.github.io/master/about/index/wangji.jpg" alt>，嗯，记下来有啥意义呢，嗯，不知道，反正闲着也是闲着.</p><p><strong>* 最后放个宝姐照片吧，写了一大堆瞎逼逼@wiaoong *</strong></p><p> <img src="https://raw.githubusercontent.com/xyw1005/xyw1005.github.io/master/about/index/fengbaobao.jpg" alt></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>category</title>
      <link href="/category/index.html"/>
      <url>/category/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
